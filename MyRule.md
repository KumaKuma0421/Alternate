# マイルール

「マイルール」は、Alternateソリューションにおけるコーディングルールを明確にし、メンテナンス向上やコード分析の向上に役立てることを目的とする。


## ■.editconfigの導入
-----------------------------------------------------------

.editconfigを導入することにより、ここで記載するコーディングルールのほとんどが適用されるため、コーディングに関する細かいルールは、このファイルによるフォーマットの適用でOKとする。

設定の詳細は、Visual Studio 2019における、.editconfigの説明は[Microsoftのサイト](https://docs.microsoft.com/ja-jp/visualstudio/ide/cpp-editorconfig-properties?view=vs-2019)を参照のこと。どのように設定がソースコードに影響するのかを確認するには、このソリューションを読み込んだ後、<br>メニュー→ツール(T)→オプション(O)→テキストエディタ→C/C++→コードスタイルで、以降のコードフォーマット内容を確認すること。


コードのフォーマットは、メニュー→編集(E)→詳細(V)→ドキュメントのフォーマット(A)を実行することで、ファイル全体のフォーマットが完了する。

４手で実施するのが面倒な場合は、Visual Studioをカスタマイズすることで、２手で実施可能となる。

カスタマイズ方法は以下の通り。これにより、ソースコードのコンテキストメニューで「ドキュメントのフォーマット」が表示される。

コマンド(O)<br>
　コンテキストメニュー(X)<br>
　　エディター コンテキストメニュー｜コードウィンドウ<br>
　　　新しいメニューの追加(E)<br>
　　　　コマンドの追加 ダイアログ<br>
　　　　　カテゴリ(G)→編集<br>
　　　　　コマンド(D)→ドキュメントのフォーマット<br>

.editconfigファイルの作成方法は、Visual Studioでソースコードのフォーマット方法を決定し、.editconfigを出力させることで、以下の内容が出力される。slnファイルの横において、ソリューションを開くと、コーディングフォーマットルールが適用される。

.editconfigの詳細内容については、[MyRule1.md](.\MyRule1.md)を参照のこと。


<font color="green">これ以降は、手動操作を伴うため、ルールの理解と徹底が求められる。</font>


## ■ファイルの構成について
-----------------------------------------------------------

C++は定義ファイル(ヘッダーファイル)と、実装ファイル(ソースファイル)の２つのファイルで概ね構成されている。実装ファイルではなく、定義ファイル側にプログラムを書くことも可能であるが、当プロジェクトにおいては、定義情報はヘッダーファイルに記載し、プログラムはソースファイルに記載することを大前提とする。

ただし、基本クラスで仮想関数、純粋仮想関数しかない場合や、テンプレート定義されたクラスで関数の実装を利用者にゆだねる場合は、この限りではない。

また、インライン実行を意図してヘッダーファイルにプログラムを実装した場合は、関数の宣言に'inline'の宣言を必ず付ける事。なお、インライン定義は**３行以内**を目標とする。


## ■ファイル名規約について
-----------------------------------------------------------

ファイル名に関しては、以下をルールとする。

- クラスの宣言、実装を主な用途とする場合は、クラス名をファイル名にする。
- main()関数やDllMain()関数を含む場合は、プロジェクト名やディレクトリ名をファイル名にする。
- インスタンスの生成が不要な、static関数で構成されたクラスは、○○○○Utilityというように「ユーティリティ」を付加する。
- インスタンスを生成して使用する多目的クラスに関しては、○○○○Helperというように「ヘルパー」を付加する。
- ファイル名は「パスカル記法<sup>(1)</sup>」を主体とし、「スネーク記法<sup>(2)</sup>」は使用しない。

>(1)"TransactionContext"のように、単語単位の先頭が大文字となる記法  
>(2)"transaction_context"のように、単語と単語の間にアンダーバーで連結する記法  
>ちなみにJavaでよく見る"getTransactionContext"のように先頭を小文字にする記法をキャメル記法と呼ぶ。

### ■■クラスの宣言と実装について

クラス名○○○○の宣言、実装を行う場合、ファイルの構成を以下のようにする。

- ヘッダーファイルは、○○○○.hで、拡張子をhxx、hppなどにしない。
- ソースファイルは、○○○○.cppで、拡張子をcxx、c++などにしない。

ただし、ヘッダーファイルだけで宣言と実装が閉じている場合は、拡張子を**hpp**とする。

１つのファイルに、１つのクラスを実装することを推奨する。  
小さいファイルの集合となる場合で、個別にファイルを実装することがかえって煩わしい場合はこの限りではない。

### ■■#includeの構成について

クラス名○○○○において、#includeの構成は以下のようにする。

- CPPファイルのインクルードはできる限り、CPPファイルと同名のHファイルだけにする。
- CPPファイルに定数定義、宣言、マクロ等をできる限り記載しない。左記の要素はできる限り再利用できるようにヘッダーファイル側に記載する。

```C++
// ○○○○.cpp

#include "○○○○.h" // 唯一となる

○○○○::○○○○
{

}
```

```C++
// ○○○○.h

#pragma once

// ここで必要なヘッダーファイルをインクルードする
#include <Windows.h>
#include <stdio.h>

class ○○○○
{
public:
    ○○○○();
    ~○○○○();
};
```

### ■■Visual Studioのプリコンパイルヘッダーを使用する構成について

Visual Studioのビルド構成には、変化のほとんどないヘッダーファイルに関して事前にコンパイル結果をバイナリとして保持する「プリコンパイル済みヘッダー」機能がある。Windows.hなど巨大なファイルだが変化することのないファイルを、この「プリコンパイル済みヘッダー」機能で初回のみコンパイルしておくのはビルド作業が高速化するので、推奨する。

#### ■■■設定方法

pch.hとpch.cppファイルを準備する。Visual StudioのC++プロジェクトを任意に新規作成し、そこからコピーするのがフォーマット的に望ましい。

プロジェクトに上記２つのファイルを登録後、プロジェクト設定を以下のように変更する。

構成プロパティ<br>
　C++<br>
　　プリコンパイル済みヘッダー<br>
　　　「プリコンパイル済みヘッダー」の設定値を「使用(/Yu)」に変更する。<br>
　　　「プリコンパイル済みヘッダー名」の設定値を「pch.h」に変更する。<br>
　　　「プリコンパイル済みヘッダー出力ファイル」の設定値を「$(IntDir)$(TargetName).pch」に変更する。<br>

pch.cppを選択して、プロパティを表示させる。コンパイルに関するファイル個別設定が表示されるので、以下の変更を行う。

構成プロパティ<br>
　C++<br>
　　プリコンパイル済みヘッダー<br>
　　　「プリコンパイル済みヘッダー」の設定値を「<font color="yellow"><b>作成(/Yc)</b></font>」に変更する。<br>
　　　「プリコンパイル済みヘッダー名」の設定値を「pch.h」に変更する。<br>
　　　「プリコンパイル済みヘッダー出力ファイル」の設定値を「$(IntDir)$(TargetName).pch」に変更する。<br>

上記設定によって、ビルドに問題が発生しないことを確認の後、以下の作業を行う。

- pch.hに変化のないヘッダーファイル（Windows.hなどのシステムヘッダーファイル）を記載する。

```c++
#pragma once

// プリコンパイルするヘッダーをここに追加します
#include "framework.h"
#include <Windows.h>
#include <vector>
#include <cmath>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <memory>
```

- pch.cppは、上記のpch.hのインクルードだけを行う。

```c++
#include "pch.h"
```

ソースファイルは、pch.hとプロジェクトで使用されるヘッダーファイルをインクルードするように修正する。

```c++

#include "pch.h"
#include "File.h"
```


## ■コードの可読性について
-----------------------------------------------------------

- 関数は小さく、同じ内容を書かないことを心掛ける。
  - デザインパターンを検討する。
  - ラムダ式を検討する。
  - リファクタリングを心掛ける。
- １つの実装ファイルに記載可能な行数は**1,000行**以下とする。
- １つの関数に記載可能な行数は**100行**以下とする。
- 変数名は格納する値の内容を先頭に記載する(形容詞となることが多い)。
  - i, j, kなどはスコープの小さいfor文などで使用し、ループスコープ外では使用しない。
  - 変数名を日本語で表すと、以下のようになる。
    - 最大の値：maxValue
    - 最小の値：minValue
    - 現在の値：currentValue
    - 直前の値：previousValue
  - 値が具体的に「温度」などである場合、以下のように具体名を使用する。
    - 最大の温度：maxTemperature
    - 最小の温度：minTemperature
    - 現在の温度：currentTemperature
    - 直前の温度：previousTemperature
  - 具体的な部分が複数で構成される場合、構造体を検討する。
    - 直前の最大の温度、直前の最小の温度、現在の最大の温度、現在の最小の温度
 ```c++
struct _Value
{
    int MinValue;
    int MaxValue;
    int CurrentValue;
} Value;

Value PreviousValue, CurrentValue;
Previous.MinValue = 0;
Previous.MaxValue = 0;
Previous.CurrentValue = 0;
 ```


## ■キャメル記法
-----------------------------------------------------------

キャメル記法は以下の変数に適用する。  
<small>※キャメル記法自体はJavaが発生源であるが、理に適った記法であるため、
当プロジェクトでも採用する。C#と同様のルールである。</small>

1. ローカル変数(キャメル部の名称に困る場合は'my'を推奨する)
1. 関数の引数(キャメル部の名称に困る場合は'prm'を推奨する)
1. クラスのインスタンス変数（先頭にアンダースコアを付ける）
  - このルールを採用することにより、関数内部でインスタンス変数とローカル変数の区別ができるため、インスタンス変数に"this->"をつけなくてよい。

```C++
class SampleValue
{
public:
    SampleValue();
    ~SampleValue();
    bool Validate(int prmValue);

private:
    int _previousValue;
    int _currentValue;
    bool IsValidValue();
};
```

```C++
bool SampleValue::Validate(int prmValue)
{
    int myValue = 0;

    if (prmValue > myValue)
    {
        int temp = _previousValue + prmValue;
    }
}
```

<font color="Yellow">上記以外の変数名、関数名に関してはパスカル記法を使用すること。</font>


## ■リターン文について
-----------------------------------------------------------

returnは関数終了間際に<font color="Yellow"><b>1つ</b></font>だけ実装する。

- 複数の出口は想定外の経路を生み、バグの元になる。
- 対策としては、例外構造で書くのが良い。
- do～whileによる、break離脱も効果がある。

```c++
bool hogehoge (int currentValue, int previousValue)
{
    bool ret; // 関数戻り値設定用

    do
    {
        ret = doSomeFunction(currentValue);
        if (!ret) break;

        ret = doSomeFunction(previousValue);
        if (!ret) break;
    } while (0);

    return ret; // 唯一のreturn
}
```

```C++
bool hogehoge2 (int currentValue, int previousValue)
{
    bool ret == true; // 関数戻り値設定用

    try
    {
        doSomeFunction(currentValue); // エラーの場合は'SomeException'をスロー
        doSomeFunction(previousValue); // エラーの場合は'SomeException'をスロー
    }
    catch (SomeException ex)
    {
        ret = false;
    }
    catch (Exception ex)
    {
        ret = false;
    }
    catch (...)
    {
        ret = false;
    }

    return ret; // 唯一のreturn
}
```


## ■プリプロセッサマクロについて
-----------------------------------------------------------
#define などのマクロ定義名は、スネーク記法を使用する。

    #define MAX_PATH 256
    #define MAX_VALUE 512

ただし、プリプロセッサー的要素がない、定数宣言等は*const*を使用した変数宣言を推奨する。こちらの方が、数値に対して型を持ち、型による厳密なリテラルの運用になるためである。

    const int MAX_PATH = 256;
    const int MAX_VALUE = 512;

ヘッダーファイルの多重インクルード防止のため、"#pragma once" をヘッダーファイル先頭に宣言する。

```c++
#pragma once

#include <Windows.h>
#include <stdio.h>
```

ライブラリの取り込み設定は、プロジェクトファイルのライブラリ設定よりも、プリプロセッサ設定を推奨する。

```c++
#pragma comment(lib, "Winmm.lib")
```


## ■Doxygenコメント
-----------------------------------------------------------

コメントはDoxygen記法を最優先とする。記載方法については、[こちら](Doxygen.md)を参照すること。


## ■境界判定は可読性を高めること
-----------------------------------------------------------

if のカッコの中に関数を書かない事。下記の記載方法は、デバッグ時に関数の結果を確認しやすくなる。またデバッガによる値の変数で、強制的に分岐テスト等を行うことができる。

```C++
a = funcA();
b = funcB();
if (a >= b)
{
    ...
}
```

## ■引数の数
-----------------------------------------------------------

引数の数が５つ以上になるなら、構造体の導入を検討する。


## ■デザインパターンの検討
-----------------------------------------------------------

Strategyは常に使用可否を検討する。また、C++11よりラムダ式が使えるようになったので、これを活用する。

```C++
auto function = [&](int value1, int value2) { return value1 + value2; };
```

```C++
template<typename Function>
int Callback (Function function) { return function(); };
```

```C++
int i = Callback(function(2, 3));
```

インスタンスの複雑な生成が必要な場合、Builderクラスを検討する。

FlyWeightでオブジェクトの再生成を抑制する。大きいオブジェクトはオブジェクトプール構造の検討を行う。
FlyWeightそのものはSingleton設計になる？

複雑な構造になった場合はFacadeやTemplateMethodを検討する。
TemplateMethodは呼出し方の統一という点では活用すべきだが、その関数そのものまでルール適用ができない。テンプレートメソッドにラムダ式を引数とすることでビジネスロジックまでフレームワークにできると思われる。

生成と処理が複雑になってきたらFactoryMethodやAbstractFactoryを検討する。